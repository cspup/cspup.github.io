<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <title>blog</title>
</head>
<link href="/css/github-markdown.css" rel="stylesheet"/>
<style>
    .markdown-body {
        box-sizing: border-box;
        min-width: 200px;
        max-width: 980px;
        margin: 0 auto;
        padding: 45px;
    }

    @media (max-width: 767px) {
        .markdown-body {
            padding: 15px;
        }
    }
</style>

<body>
<div class="markdown-body" id="blog-view">
    <ul>
<li><a href="#剑指-offer-03-数组中重复的数字">剑指 Offer 03. 数组中重复的数字</a></li>
<li><a href="#剑指-offer-04-二维数组中的查找">剑指 Offer 04. 二维数组中的查找</a></li>
<li><a href="#剑指-offer-05-替换空格">剑指 Offer 05. 替换空格</a></li>
<li><a href="#剑指-offer-06-从尾到头打印链表">剑指 Offer 06. 从尾到头打印链表</a></li>
<li><a href="#剑指-offer-07-重建二叉树">剑指 Offer 07. 重建二叉树</a></li>
<li><a href="#剑指-offer-09-用两个栈实现队列">剑指 Offer 09. 用两个栈实现队列</a></li>
<li><a href="#剑指-offer-10--i-斐波那契数列">剑指 Offer 10- I. 斐波那契数列</a></li>
<li><a href="#剑指-offer-10--ii-青蛙跳台阶问题">剑指 Offer 10- II. 青蛙跳台阶问题</a></li>
<li><a href="#剑指-offer-11-旋转数组的最小数字">剑指 Offer 11. 旋转数组的最小数字</a></li>
<li><a href="#剑指-offer-12-矩阵中的路径">剑指 Offer 12. 矩阵中的路径</a></li>
<li><a href="#剑指-offer-13-机器人的运动范围">剑指 Offer 13. 机器人的运动范围</a></li>
<li><a href="#剑指-offer-30-包含min函数的栈">剑指 Offer 30. 包含min函数的栈</a></li>
<li><a href="#剑指-offer-24-反转链表">剑指 Offer 24. 反转链表</a></li>
<li><a href="#剑指-offer-35-复杂链表的复制">剑指 Offer 35. 复杂链表的复制</a></li>
<li><a href="#剑指-offer-58---ii-左旋转字符串">剑指 Offer 58 - II. 左旋转字符串</a></li>
<li><a href="#剑指-offer-53---i-在排序数组中查找数字-i">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></li>
<li><a href="#剑指-offer-53---ii-0n-1中缺失的数字">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></li>
<li><a href="#面试题50-第一个只出现一次的字符">面试题50. 第一个只出现一次的字符</a></li>
</ul>
<h2 id="剑指-offer-03-数组中重复的数字">剑指 Offer 03. 数组中重复的数字</h2>
<p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p>示例 1：</p>
<p>输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3
 </p>
<p>限制：</p>
<p>2 &lt;= n &lt;= 100000</p>
<p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>解法一：暴力</p>
<pre><code class="language-Java">class Solution {
    public int findRepeatNumber(int[] nums) {
        for (int i=0;i&lt;nums.length-1;i++){
            for (int j=i+1;j&lt;nums.length;j++){
                if (nums[i]==nums[j]){
                    return nums[i];
                }
            }
        }
        return nums[0];
    }
}
</code></pre>
<p>解法二：使用HashSet</p>
<pre><code class="language-Java">class Solution {
    public int findRepeatNumber(int[] nums) {
        HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();
        for (int i=0;i&lt;nums.length;i++){
            if (!set.add(nums[i])){
                return nums[i];
            }
        }
        return nums[0];
    }
}
</code></pre>
<h2 id="剑指-offer-04-二维数组中的查找">剑指 Offer 04. 二维数组中的查找</h2>
<p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>示例:</p>
<p>现有矩阵 matrix 如下：</p>
<p>[
[1,   4,  7, 11, 15],
[2,   5,  8, 12, 19],
[3,   6,  9, 16, 22],
[10, 13, 14, 17, 24],
[18, 21, 23, 26, 30]
]
给定 target = 5，返回 true。</p>
<p>给定 target = 20，返回 false。</p>
<p>限制：</p>
<p>0 &lt;= n &lt;= 1000</p>
<p>0 &lt;= m &lt;= 1000</p>
<p>链接：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/</p>
<p>解法一：暴力法直接遍历</p>
<p>解法二：线性查找</p>
<pre><code class="language-Java">class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        if(matrix.length==0||matrix[0].length==0){
            return false;
        }

        int n = 0;
        int m = matrix[0].length-1;

        while (n&lt;matrix.length&amp;&amp;m&gt;=0){
            if (matrix[n][m]==target){
                return true;
            }else if (target&gt;matrix[n][m]){
                n++;
            }else{
                m--;
            }
        }
        
        return false;
    }
}

</code></pre>
<h2 id="剑指-offer-05-替换空格">剑指 Offer 05. 替换空格</h2>
<p>请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。</p>
<p>示例 1：</p>
<p>输入：s = &quot;We are happy.&quot;
输出：&quot;We%20are%20happy.&quot;</p>
<p>限制：</p>
<p>0 &lt;= s 的长度 &lt;= 10000</p>
<p>链接：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/</p>
<pre><code class="language-Java">class Solution {
    public String replaceSpace(String s) {
       return s.replaceAll(&quot; &quot;,&quot;%20&quot;);
    }
}
</code></pre>
<h2 id="剑指-offer-06-从尾到头打印链表">剑指 Offer 06. 从尾到头打印链表</h2>
<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p>示例 1：</p>
<p>输入：head = [1,3,2]
输出：[2,3,1]</p>
<p>限制：</p>
<p>0 &lt;= 链表长度 &lt;= 10000</p>
<p>链接：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/</p>
<p>解法一：遍历两遍</p>
<pre><code class="language-Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public int[] reversePrint(ListNode head) {
        ListNode head1 = head;
        
        int n=0;

        while (head1!=null){
            n++;
            head1 = head1.next;
        }
        

        int[] re = new int[n];

        while (head!=null){
            re[--n] = head.val;
            head = head.next;
        }
        return re;
    }
}
</code></pre>
<p>解法二：用栈</p>
<pre><code class="language-Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public int[] reversePrint(ListNode head) {
        Stack&lt;ListNode&gt; stack = new Stack&lt;ListNode&gt;();
        ListNode temp = head;
        while (temp != null) {
            stack.push(temp);
            temp = temp.next;
        }
        int size = stack.size();
        int[] print = new int[size];
        for (int i = 0; i &lt; size; i++) {
            print[i] = stack.pop().val;
        }
        return print;
    }
}

</code></pre>
<h2 id="剑指-offer-07-重建二叉树">剑指 Offer 07. 重建二叉树</h2>
<p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p>
<p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>示例 1:</p>
<p>Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
示例 2:</p>
<p>Input: preorder = [-1], inorder = [-1]
Output: [-1]</p>
<p>限制：</p>
<p>0 &lt;= 节点个数 &lt;= 5000</p>
<p>解法一：递归构建左右子树</p>
<pre><code class="language-Java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if (preorder.length==0||inorder.length==0){
            return null;
        }
        TreeNode head = new TreeNode(preorder[0]);

        if (preorder.length==1||inorder.length==1){
            return head;
        }

        int i = 0;
        
        for (i=0;i&lt;inorder.length;i++){
            if (inorder[i]==preorder[0]){
                break;
            }
        }
        
        int[] leftPreorder = Arrays.copyOfRange(preorder,1,i+1);
        int[] leftInorder = Arrays.copyOfRange(inorder,0,i);
        // 左子树
        head.left = buildTree(leftPreorder,leftInorder);

        if (i&gt;=preorder.length){
            head.right = null;
        }else {
            int[] rightPreorder = Arrays.copyOfRange(preorder,i+1,preorder.length);
            int[] rightInorder = Arrays.copyOfRange(inorder,i+1,inorder.length);

            //右子树
            head.right = buildTree(rightPreorder,rightInorder);
        }


        return head;

    }
}

</code></pre>
<p>优化：可用HashMap构建节点映射，快速找到节点</p>
<pre><code class="language-Java">class Solution {
    private Map&lt;Integer, Integer&gt; indexMap;

    public TreeNode myBuildTree(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) {
        if (preorder_left &gt; preorder_right) {
            return null;
        }

        // 前序遍历中的第一个节点就是根节点
        int preorder_root = preorder_left;
        // 在中序遍历中定位根节点
        int inorder_root = indexMap.get(preorder[preorder_root]);
        
        // 先把根节点建立出来
        TreeNode root = new TreeNode(preorder[preorder_root]);
        // 得到左子树中的节点数目
        int size_left_subtree = inorder_root - inorder_left;
        // 递归地构造左子树，并连接到根节点
        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素
        root.left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);
        // 递归地构造右子树，并连接到根节点
        // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素
        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);
        return root;
    }

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int n = preorder.length;
        // 构造哈希映射，帮助我们快速定位根节点
        indexMap = new HashMap&lt;Integer, Integer&gt;();
        for (int i = 0; i &lt; n; i++) {
            indexMap.put(inorder[i], i);
        }
        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h2 id="剑指-offer-09-用两个栈实现队列">剑指 Offer 09. 用两个栈实现队列</h2>
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<p>示例 1：</p>
<p>输入：
[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]
[[],[3],[],[]]
输出：[null,null,3,-1]
示例 2：</p>
<p>输入：
[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]
提示：</p>
<p>1 &lt;= values &lt;= 10000
最多会对 appendTail、deleteHead 进行 10000 次调用</p>
<p>链接：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/</p>
<p>方法一：</p>
<pre><code class="language-Java">class CQueue {

    private Stack&lt;Integer&gt; s1;
     private Stack&lt;Integer&gt; s2;
    public CQueue() {
        s1 = new Stack&lt;&gt;();
        s2 = new Stack&lt;&gt;();
    }
    
    public void appendTail(int value) {
        s1.push(value);
    }
    
    public int deleteHead() {
        if (s1.isEmpty()){
            return -1;
        }

        while (!s1.isEmpty()){
            s2.push(s1.pop());
        }
        int re = s2.pop();

        while(!s2.isEmpty()){
            s1.push(s2.pop());
        }

        return re;
    }
}

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue obj = new CQueue();
 * obj.appendTail(value);
 * int param_2 = obj.deleteHead();
 */

</code></pre>
<h2 id="剑指-offer-10--i-斐波那契数列">剑指 Offer 10- I. 斐波那契数列</h2>
<p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p>
<p>F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>示例 1：</p>
<p>输入：n = 2
输出：1
示例 2：</p>
<p>输入：n = 5
输出：5</p>
<p>提示：</p>
<p>0 &lt;= n &lt;= 100</p>
<p>链接：https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/</p>
<p>解法一：记忆递归</p>
<pre><code class="language-Java">class Solution {
    Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();
    public int fib(int n) {
        if (n&lt;2){
            return n;
        }
        if(map.get(n)!=null){
            return map.get(n);
        }
        int sum = (fib(n-1)+fib(n-2))%1000000007;
        map.put(n,sum);
        return sum;
    }
}
</code></pre>
<p>解法二：动态规划</p>
<pre><code class="language-Java">class Solution {
    public int fib(int n) {
        final int MOD = 1000000007;
        if (n &lt; 2) {
            return n;
        }
        int p = 0, q = 0, r = 1;
        for (int i = 2; i &lt;= n; ++i) {
            p = q; 
            q = r; 
            r = (p + q) % MOD;
        }
        return r;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/fei-bo-na-qi-shu-lie-by-leetcode-solutio-hbss/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h2 id="剑指-offer-10--ii-青蛙跳台阶问题">剑指 Offer 10- II. 青蛙跳台阶问题</h2>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>示例 1：</p>
<p>输入：n = 2
输出：2
示例 2：</p>
<p>输入：n = 7
输出：21
示例 3：</p>
<p>输入：n = 0
输出：1
提示：</p>
<p>0 &lt;= n &lt;= 100</p>
<p>可转化为斐波那契数列问题求解。设n阶台阶有f(n)种跳法，最后一步只有两种跳法跳1阶或2阶，则f(n) = f(n-1)+f(n-2)</p>
<p>解法一：记忆递归</p>
<pre><code class="language-Java">class Solution {
    HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();
    public int numWays(int n) {
        if (n&lt;2){
            return 1;
        }
        if (map.get(n)!=null){
            return map.get(n);
        }else {
            int sum = (numWays(n-1)+numWays(n-2))%1000000007;
            map.put(n,sum);
            return sum;
        }
       
    }
}
</code></pre>
<p>解法二：动态规划</p>
<pre><code class="language-Java">class Solution {
    public int numWays(int n) {
        int[] dp = new int[Math.max(n+1,3)];
        dp[0] = 1;
        dp[1] = 1;
        dp[2] = 2;

        for (int i=3;i&lt;=n;i++){
            dp[i] = (dp[i-1]+dp[i-2])%1000000007;
        }
        return dp[n];
    }
}
</code></pre>
<h2 id="剑指-offer-11-旋转数组的最小数字">剑指 Offer 11. 旋转数组的最小数字</h2>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p>
<p>给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为1。</p>
<p>示例 1：</p>
<p>输入：[3,4,5,1,2]
输出：1
示例 2：</p>
<p>输入：[2,2,2,0,1]
输出：0</p>
<p>链接：https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/</p>
<p>解法一：O(n)的解法</p>
<pre><code class="language-Java">class Solution {
    public int minArray(int[] numbers) {
        for (int i=0;i&lt;numbers.length;i++){
            if (numbers[0]&gt;numbers[i]){
                return numbers[i];
            }
        }
        return numbers[0];
    }
}
</code></pre>
<p>解法二：二分查找O(logn)</p>
<pre><code class="language-Java">class Solution {
    public int minArray(int[] numbers) {
        int low=0;
        int high = numbers.length-1;
        while (low&lt;high){
            // 防止溢出
          int pivot = low +(high-low)/2;

            if (numbers[pivot]&gt;numbers[high]){
                low = pivot+1;
            }
            else if (numbers[pivot]&lt;numbers[high]){
                high = pivot;
            }else{
                high--;
            }
        }

        return numbers[low];
    }
}
</code></pre>
<h2 id="剑指-offer-12-矩阵中的路径">剑指 Offer 12. 矩阵中的路径</h2>
<p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>例如，在下面的 3×4 的矩阵中包含单词 &quot;ABCCED&quot;（单词中的字母已标出）。</p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="图片" /></p>
<p>示例 1：</p>
<p>输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;
输出：true
示例 2：</p>
<p>输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;
输出：false</p>
<p>链接：https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/</p>
<p>解法一：DFS</p>
<pre><code class="language-Java">class Solution {
    public boolean exist(char[][] board, String word) {
        char[] words = word.toCharArray();

        for (int i=0;i&lt;board.length;i++){
            for (int j=0;j&lt;board[0].length;j++){
                if(dfs(board,i,j,words,0)){
                    return true;
                }
            }
        }
        return false;
    }

    public boolean dfs (char[][] board,int i,int j,char[] words,int k){
        // 边界
        if (i&gt;=board.length||j&gt;=board[0].length||i&lt;0||j&lt;0||board[i][j] != words[k]){
            return false;
        }
        if(k == words.length - 1) {
            return true;
        }
        
        board[i][j] = '\0';
        // 上下左右搜索
        boolean res = dfs(board,i+1,j,words,k+1)||dfs(board,i-1,j,words,k+1)||dfs(board,i,j+1,words,k+1)||dfs(board,i,j-1,words,k+1);

        board[i][j] = words[k];
        return res;

    }
}
</code></pre>
<h2 id="剑指-offer-13-机器人的运动范围">剑指 Offer 13. 机器人的运动范围</h2>
<p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p>示例 1：</p>
<p>输入：m = 2, n = 3, k = 1
输出：3
示例 2：</p>
<p>输入：m = 3, n = 1, k = 0
输出：1
提示：</p>
<p>1 &lt;= n,m &lt;= 100
0 &lt;= k &lt;= 20</p>
<p>链接：https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/</p>
<p>解法一：BFS</p>
<pre><code class="language-Java">class Solution {
    public int movingCount(int m, int n, int k) {
        if (k==0){
            return 1;
        }

        Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();
        int ans = 1;
        int[] dx = {0,1};
        int[] dy = {1,0};

        boolean[][] vis = new boolean[m][n];
        queue.offer(new int[]{0,0});
        vis[0][0] = true;

        while(!queue.isEmpty()){
            int[] cell = queue.poll();
            int x = cell[0];
            int y = cell[1];
            for (int i=0;i&lt;2;i++){
                int tx = x + dx[i];
                int ty = y + dy[i];

                if (tx&lt;0||tx&gt;=m||ty&lt;0||ty&gt;=n||vis[tx][ty]||get(tx)+get(ty)&gt;k){
                    continue;
                }
                queue.offer(new int[]{tx,ty});
                vis[tx][ty] = true;
                ans++;
            }
        }
        return ans;


    }
    int get(int n){
        int res = 0;
        while (n!=0){
            res += n%10;
            n = n/10;
        }
        return res;
    }
}
</code></pre>
<h2 id="剑指-offer-30-包含min函数的栈">剑指 Offer 30. 包含min函数的栈</h2>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<p>示例:</p>
<p>MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.min();   --&gt; 返回 -3.
minStack.pop();
minStack.top();      --&gt; 返回 0.
minStack.min();   --&gt; 返回 -2.</p>
<p>提示：</p>
<p>各函数的调用总次数不超过 20000 次</p>
<p>链接：https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/</p>
<p>解法一：使用辅助栈</p>
<pre><code class="language-Java">class MinStack {
    private final Stack&lt;Integer&gt; s1;
    private final Stack&lt;Integer&gt; s2;
    /** initialize your data structure here. */
    public MinStack() {
        this.s1 = new Stack&lt;&gt;();
        this.s2 = new Stack&lt;&gt;();
    }

    public void push(int x) {
        s1.push(x);
        if (s2.isEmpty()||x&lt;=s2.peek()){
            s2.push(x);
        }
    }

    public void pop() {
        if (s1.pop().equals(s2.peek())){
            s2.pop();
        }

    }

    public int top() {
        return s1.peek();
    }

    public int min() {
        return s2.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.min();
 */
</code></pre>
<h2 id="剑指-offer-24-反转链表">剑指 Offer 24. 反转链表</h2>
<p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<p>限制：</p>
<p>0 &lt;= 节点个数 &lt;= 5000</p>
<p>链接：https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/</p>
<p>解法一：使用辅助栈</p>
<pre><code class="language-Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {

        if (head==null||head.next==null){
            return head;
        }
        

        Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();
        while (head!=null){
            stack.push(head);
            head = head.next;
        }
        ListNode head2 = new ListNode(stack.pop().val);
        ListNode head3 = head2;

        while (!stack.isEmpty()){
            head2.next = new ListNode(stack.pop().val);
            head2 = head2.next;

        }

        return head3;
    }
}
</code></pre>
<p>解法二：迭代</p>
<p>1-&gt;2-&gt;3-&gt;4-&gt;null<br />
pre前一个元素、curr当前元素、next下一个元素</p>
<pre><code class="language-Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode curr = head;

        while (curr!=null){
            ListNode next = curr.next;
            curr.next = pre;
            pre = curr;
            curr = next;
        }

        return pre;
    }
}
</code></pre>
<h2 id="剑指-offer-35-复杂链表的复制">剑指 Offer 35. 复杂链表的复制</h2>
<p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png" alt="示例 1" /></p>
<p>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</p>
<p>示例 2：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png" alt="示例 2" /></p>
<p>输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]</p>
<p>示例 3：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png" alt="示例 3" /></p>
<p>输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]</p>
<p>示例 4：</p>
<p>输入：head = []
输出：[]
解释：给定的链表为空（空指针），因此返回 null。</p>
<p>提示：</p>
<p>-10000 &lt;= Node.val &lt;= 10000
Node.random 为空（null）或指向链表中的节点。
节点数目不超过 1000 。</p>
<p>链接：https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/</p>
<p>解法一：回溯 + 哈希表</p>
<p>在复制时由于有random的存在，后面的元素可能还未被创建，因此可以让每个节点的拷贝独立。<br />
用哈希表保存拷贝的元素，对于一个元素now：先进行它本身的拷贝，再分别递归进行now.next的拷贝、now.random的拷贝，就得到了当前节点next和random的元素指针，最后将指针赋给当前元素，就完成了当前元素的完全赋值。</p>
<pre><code class="language-Java">/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/
class Solution {
    Map&lt;Node,Node&gt; cache = new HashMap&lt;&gt;();
    public Node copyRandomList(Node head) {
        if (head==null){
            return null;
        }

        while (!cache.containsKey(head)){
            Node nodeNew = new Node(head.val);
            cache.put(head,nodeNew);
            nodeNew.next = copyRandomList(head.next);
            nodeNew.random = copyRandomList(head.random);
        }

        return cache.get(head);
    }
}
</code></pre>
<h2 id="剑指-offer-58---ii-左旋转字符串">剑指 Offer 58 - II. 左旋转字符串</h2>
<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</p>
<p>示例 1：</p>
<p>输入: s = &quot;abcdefg&quot;, k = 2
输出: &quot;cdefgab&quot;
示例 2：</p>
<p>输入: s = &quot;lrloseumgh&quot;, k = 6
输出: &quot;umghlrlose&quot;</p>
<p>限制：</p>
<p>1 &lt;= k &lt; s.length &lt;= 10000</p>
<p>链接：https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/</p>
<p>解法一：直接使用subString</p>
<pre><code class="language-Java">class Solution {
    public String reverseLeftWords(String s, int n) {
        return s.substring(n, s.length()) + s.substring(0, n);
    }
}
</code></pre>
<p>解法二：用StringBuilder</p>
<pre><code class="language-Java">class Solution {
    public String reverseLeftWords(String s, int n) {
        StringBuilder sb1 = new StringBuilder();
        StringBuilder sb2 = new StringBuilder();

        for (int i=0;i&lt;s.length();i++){
            if (i&lt;n){
                sb2.append(s.charAt(i));
            }else{
                sb1.append(s.charAt(i));
            }
        }
        sb1.append(sb2.toString());

        return sb1.toString();

    }
}

</code></pre>
<h2 id="剑指-offer-53---i-在排序数组中查找数字-i">剑指 Offer 53 - I. 在排序数组中查找数字 I</h2>
<p>统计一个数字在排序数组中出现的次数。</p>
<p>示例 1:</p>
<p>输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
示例 2:</p>
<p>输入: nums = [5,7,7,8,8,10], target = 6
输出: 0</p>
<p>提示：</p>
<p>0 &lt;= nums.length &lt;= 105
-109 &lt;= nums[i] &lt;= 109
nums 是一个非递减数组
-109 &lt;= target &lt;= 109</p>
<p>链接：https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/</p>
<p>解法一：二分查找</p>
<p>从左右两边进行两次查找，找到左边第一个匹配的和右边第一个匹配的，相减就得结果。</p>
<pre><code class="language-Java">
class Solution {
    public int search(int[] nums, int target) {
        
        int left = binarySearch(nums,target,true);
        int right =  binarySearch(nums,target,false)-1;
        if (left&lt;=right&amp;&amp;right&lt;nums.length&amp;&amp;nums[left]==target&amp;&amp;nums[right]==target){
            return right-left+1;
        }
        return 0;
    }

    public int binarySearch(int[] nums,int target,boolean left){
        int low = 0;
        int high = nums.length-1;
        int res = nums.length;

        while(low&lt;=high){
            int mid = low + (high-low)/2;
            if (nums[mid]&gt;target||(left&amp;&amp;nums[mid]&gt;=target)){
                high = mid-1;
                res = mid;
            }else{
                low = mid+1;
            }
        }
        return res;
    }
}
</code></pre>
<h2 id="剑指-offer-53---ii-0n-1中缺失的数字">剑指 Offer 53 - II. 0～n-1中缺失的数字</h2>
<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<p>示例 1:</p>
<p>输入: [0,1,3]
输出: 2
示例 2:</p>
<p>输入: [0,1,2,3,4,5,6,7,9]
输出: 8</p>
<p>限制：</p>
<p>1 &lt;= 数组长度 &lt;= 10000</p>
<p>链接：https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/</p>
<p>解法一：二分查找</p>
<p>将数组看成左右两块，左侧能和下标对应的，右侧不能对应，找到右侧第一个不能对应下标的就是第一个缺失的数字。</p>
<pre><code class="language-Java">class Solution {
    public int missingNumber(int[] nums) {
        int low = 0;
        int high = nums.length-1;
        while (low&lt;=high){
            int mid = low+(high-low)/2;
            if (nums[mid]==mid){
                low = mid+1;
            }else{
                high = mid-1;
            }
        }
        return low;
    }
}
</code></pre>
<h2 id="面试题50-第一个只出现一次的字符">面试题50. 第一个只出现一次的字符</h2>
<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>
<p>示例 1:</p>
<p>输入：s = &quot;abaccdeff&quot;
输出：'b'
示例 2:</p>
<p>输入：s = &quot;&quot;
输出：' '</p>
<p>限制：</p>
<p>0 &lt;= s 的长度 &lt;= 50000</p>
<p>链接：https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/</p>
<p>解法一：使用哈希表</p>
<pre><code class="language-Java">class Solution {
    public char firstUniqChar(String s) {
        HashMap&lt;Character,Integer&gt; map = new HashMap&lt;&gt;();

        for (char ch:s.toCharArray()){
            if (map.containsKey(ch)){
                map.put(ch,map.get(ch)+1);
            }else {
                map.put(ch,1);
            }
        }
        for (char ch:s.toCharArray()){
            if (map.get(ch)==1){
                return ch;
            }
        }
        return ' ';
    }
}
</code></pre>

</div>
</body>
<script>
</script>

</html>
